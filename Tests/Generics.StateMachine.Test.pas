unit Generics.StateMachine.Test;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
  TestFramework, Generics.StateMachine, System.SysUtils;

type
  // Test methods for class TConfiguredTrigger
  TestTConfiguredTrigger = class(TTestCase)
  strict private
  public
  published
    procedure TestEnumTriggerNilGuard;
    procedure TestEnumTriggerPassingGuard;
    procedure TestEnumTriggerFailingGuard;
    procedure TestEnumTriggerGuardHasAccessToTrigger;
    procedure TestStringTriggerNilGuard;
    procedure TestStringTriggerPassingGuard;
    procedure TestStringTriggerFailingGuard;
  end;
  // Test methods for class TConfiguredState

  TestTConfiguredState = class(TTestCase)
  strict private
  published
    procedure TestAddEnumTrigger;
    procedure TestAddStringTrigger;
    procedure TestEnumOnExit;
    procedure TestEnumNoOnExitWithFailingGuard;
    procedure TestEnumOnEntry;
    procedure TestEnumNoOnEntryWithFailingGuard;
    procedure TestEnumInitialStateOnEntry;
    procedure TestStringOnExit;
    procedure TestStringNoOnExitWithFailingGuard;
    procedure TestStringOnEntry;
    procedure TestStringNoOnEntryWithFailingGuard;
    procedure TestStringInitialStateOnEntry;
  end;
  // Test methods for class TStateMachine

  TestTStateMachine = class(TTestCase)
  published
    procedure TestAddState;
    procedure TestActiveWithNoInitialState;
    procedure TestTwoInitialStates;
    procedure TestUnreachableStates;
  end;

  // test data
  TDoorStates = (dsOpen, dsClosed, dsSlightlyAjar, dsMoreAjar);
  TDoorTriggers = (dtOpen, dtClose);

  ENotifyException = class(Exception);

  TestEnumDoorStates = class(TTestCase)
  strict private
    FDoorStates: TStateMachine<TDoorStates, TDoorTriggers>;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestNumberOfStates;
    procedure TestInitialState;
    procedure TestTriggerNoGuard;
    procedure TestTriggerExists;
    procedure TestTriggerExistsFalse;
  end;

  TestStringDoorStates = class(TTestCase)
  strict private
    FDoorStates: TStateMachine<String, String>;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestNumberOfStates;
    procedure TestInitialState;
    procedure TestTriggerNoGuard;
  end;

const
  DoorStateOpen = 'Open';
  DoorStateClosed = 'Closed';
  DoorTriggerOpen = 'Open';
  DoorTriggerClose = 'Close';

implementation

procedure TestTConfiguredTrigger.TestEnumTriggerFailingGuard;
var
  DoorStates: TStateMachine<TDoorStates, TDoorTriggers>;
  FailingGuard: TGuardProc<TDoorTriggers>;
begin
  FailingGuard := function(Trigger : TDoorTriggers): boolean
    begin
      Result := False;
    end;

  DoorStates := TStateMachine<TDoorStates, TDoorTriggers>.Create;
  try
    DoorStates.State(TDoorStates.dsOpen).Trigger(TDoorTriggers.dtClose,
      TDoorStates.dsClosed);
    DoorStates.State(TDoorStates.dsClosed).Initial.Trigger(TDoorTriggers.dtOpen,
      TDoorStates.dsOpen, FailingGuard);
    DoorStates.Active := True;
    try
      DoorStates.CurrentState.Execute(TDoorTriggers.dtOpen);
      Fail('Guard should have failed');
    except
      on E: EGuardFailure do
        Check(True, 'Guard failed as expected');
    end;
  finally
    DoorStates.Active := False;
    DoorStates.Free;
  end;
end;

procedure TestTConfiguredTrigger.TestEnumTriggerGuardHasAccessToTrigger;
var
  DoorStates: TStateMachine<TDoorStates, TDoorTriggers>;
   CheckingGuard: TGuardProc<TDoorTriggers>;
begin
  CheckingGuard := function(Trigger : TDoorTriggers): boolean
    begin

      Result := Trigger = TDoorTriggers.dtOpen;
    end;

  DoorStates := TStateMachine<TDoorStates, TDoorTriggers>.Create;
  try
    DoorStates.State(TDoorStates.dsOpen).Trigger(TDoorTriggers.dtClose,
      TDoorStates.dsClosed);
    DoorStates.State(TDoorStates.dsClosed).Initial.Trigger(TDoorTriggers.dtOpen,
      TDoorStates.dsOpen, CheckingGuard);
    DoorStates.Active := True;
    try
      DoorStates.CurrentState.Execute(TDoorTriggers.dtOpen);
      Check(True, 'No exception, as expected');
    except
      on E: Exception do
        Fail(Format('Unexpected exception %s', [E.ToString]));
    end;
  finally
    DoorStates.Active := False;
    DoorStates.Free;
  end;
end;

procedure TestTConfiguredTrigger.TestEnumTriggerNilGuard;
var
  DoorStates: TStateMachine<TDoorStates, TDoorTriggers>;
begin
  DoorStates := TStateMachine<TDoorStates, TDoorTriggers>.Create;
  try
    DoorStates.State(TDoorStates.dsOpen).Trigger(TDoorTriggers.dtClose,
      TDoorStates.dsClosed);
    DoorStates.State(TDoorStates.dsClosed).Initial.Trigger(TDoorTriggers.dtOpen,
      TDoorStates.dsOpen);
    DoorStates.Active := True;
    try
      DoorStates.CurrentState.Execute(TDoorTriggers.dtOpen);
      Check(True, 'No exception, as expected');
    except
      on E: Exception do
        Fail(Format('Unexpected exception %s', [E.ToString]));
    end;
  finally
    DoorStates.Active := False;
    DoorStates.Free;
  end;
end;

procedure TestTConfiguredTrigger.TestEnumTriggerPassingGuard;
var
  DoorStates: TStateMachine<TDoorStates, TDoorTriggers>;
  PassingGuard: TGuardProc<TDoorTriggers>;
begin
  PassingGuard := function(Trigger : TDoorTriggers): boolean
    begin
      Result := True;
    end;

  DoorStates := TStateMachine<TDoorStates, TDoorTriggers>.Create;
  try
    DoorStates.State(TDoorStates.dsOpen).Trigger(TDoorTriggers.dtClose,
      TDoorStates.dsClosed);
    DoorStates.State(TDoorStates.dsClosed).Initial.Trigger(TDoorTriggers.dtOpen,
      TDoorStates.dsOpen, PassingGuard);
    DoorStates.Active := True;
    try
      DoorStates.CurrentState.Execute(TDoorTriggers.dtOpen);
      Check(True, 'No exception, as expected');
    except
      on E: Exception do
        Fail(Format('Unexpected exception %s', [E.ToString]));
    end;
  finally
    DoorStates.Active := False;
    DoorStates.Free;
  end;
end;

procedure TestTConfiguredTrigger.TestStringTriggerFailingGuard;
var
  DoorStates: TStateMachine<string, string>;
  FailingGuard: TGuardProc<string>;
begin
  FailingGuard := function(Trigger : string): boolean
    begin
      Result := False;
    end;

  DoorStates := TStateMachine<string, string>.Create;
  try
    DoorStates.State(DoorStateOpen).Trigger(DoorTriggerClose, DoorStateClosed);
    DoorStates.State(DoorStateClosed).Initial.Trigger(DoorTriggerOpen,
      DoorStateOpen, FailingGuard);
    DoorStates.Active := True;
    try
      DoorStates.CurrentState.Execute(DoorTriggerOpen);
      Fail('Guard should have failed');
    except
      on E: EGuardFailure do
        Check(True, 'Guard failed as expected');
    end;
  finally
    DoorStates.Active := False;
    DoorStates.Free;
  end;
end;

procedure TestTConfiguredTrigger.TestStringTriggerNilGuard;
var
  DoorStates: TStateMachine<string, string>;
begin
  DoorStates := TStateMachine<string, string>.Create;
  try
    DoorStates.State(DoorStateOpen).Trigger(DoorTriggerClose, DoorStateClosed);
    DoorStates.State(DoorStateClosed).Initial.Trigger(DoorTriggerOpen,
      DoorStateOpen);
    DoorStates.Active := True;
    try
      DoorStates.CurrentState.Execute(DoorTriggerOpen);
      Check(True, 'No exception, as expected');
    except
      on E: Exception do
        Fail(Format('Unexpected exception %s', [E.ToString]));
    end;
  finally
    DoorStates.Active := False;
    DoorStates.Free;
  end;
end;

procedure TestTConfiguredTrigger.TestStringTriggerPassingGuard;
var
  DoorStates: TStateMachine<string, string>;
  PassingGuard: TGuardProc<string>;
begin
  PassingGuard := function(Trigger : string): boolean
    begin
      Result := True;
    end;

  DoorStates := TStateMachine<string, string>.Create;
  try
    DoorStates.State(DoorStateOpen).Trigger(DoorTriggerClose, DoorStateClosed);
    DoorStates.State(DoorStateClosed).Initial.Trigger(DoorTriggerOpen,
      DoorStateOpen, PassingGuard);
    DoorStates.Active := True;
    try
      DoorStates.CurrentState.Execute(DoorTriggerOpen);
      Check(True, 'No exception, as expected');
    except
      on E: Exception do
        Fail(Format('Unexpected exception %s', [E.ToString]));
    end;
  finally
    DoorStates.Active := False;
    DoorStates.Free;
  end;
end;

procedure TestTConfiguredState.TestAddEnumTrigger;
var
  FDoorStates: TStateMachine<TDoorStates, TDoorTriggers>;
begin
  FDoorStates := TStateMachine<TDoorStates, TDoorTriggers>.Create;
  try
    FDoorStates.State(TDoorStates.dsOpen).Initial;
    Check(FDoorStates.InitialState.TriggerCount = 0,
      Format('State should have 0 states, but has %d',
      [FDoorStates.InitialState.TriggerCount]));
    FDoorStates.InitialState.Trigger(TDoorTriggers.dtOpen, TDoorStates.dsOpen);
    Check(FDoorStates.InitialState.TriggerCount = 1,
      Format('State should have 1 state, but has %d',
      [FDoorStates.InitialState.TriggerCount]));
  finally
    FDoorStates.Free;
  end;
end;

procedure TestTConfiguredState.TestAddStringTrigger;
var
  FDoorStates: TStateMachine<String, String>;
begin
  FDoorStates := TStateMachine<String, String>.Create;
  try
    FDoorStates.State(DoorStateOpen).Initial;
    Check(FDoorStates.InitialState.TriggerCount = 0,
      Format('State should have 0 states, but has %d',
      [FDoorStates.InitialState.TriggerCount]));
    FDoorStates.InitialState.Trigger(DoorTriggerOpen, DoorStateOpen);
    Check(FDoorStates.InitialState.TriggerCount = 1,
      Format('State should have 1 state, but has %d',
      [FDoorStates.InitialState.TriggerCount]));
  finally
    FDoorStates.Free;
  end;
end;

procedure TestTConfiguredState.TestEnumInitialStateOnEntry;
var
  LOnEntry: TTransitionProc;
  FDoorStates: TStateMachine<TDoorStates, TDoorTriggers>;
begin
  LOnEntry := procedure
    begin
      raise ENotifyException.Create('In OnEntry');
    end;

  FDoorStates := TStateMachine<TDoorStates, TDoorTriggers>.Create;
  try
    FDoorStates.State(TDoorStates.dsOpen).Initial.OnEntry(LOnEntry)
      .Trigger(dtClose, dsClosed);
    FDoorStates.State(dsClosed).Trigger(dtOpen, dsOpen);
    try
      FDoorStates.Active := True;
      Check(False, 'Initial State dsOpen OnEntry failed to fire on Activate');
    except
      on E: ENotifyException do
        Check(True, 'as expected');
    end;
  finally
    FDoorStates.Free;
  end;
end;

procedure TestTConfiguredState.TestEnumNoOnEntryWithFailingGuard;
var
  LOnEntry: TTransitionProc;
  LFailingGuard: TGuardProc<TDoorTriggers>;
  FDoorStates: TStateMachine<TDoorStates, TDoorTriggers>;
begin
  LOnEntry := procedure
    begin
      raise ENotifyException.Create('In OnExit');
    end;

  LFailingGuard := function(Trigger : TDoorTriggers): boolean
    begin
      Result := False;
    end;

  FDoorStates := TStateMachine<TDoorStates, TDoorTriggers>.Create;
  try
    FDoorStates.State(TDoorStates.dsOpen).Initial.Trigger(dtClose, dsClosed,
      LFailingGuard);
    FDoorStates.State(dsClosed).OnEntry(LOnEntry).Trigger(dtOpen, dsOpen);
    FDoorStates.Active := True;
    try
      FDoorStates.CurrentState.Execute(dtClose);
    except
      on E: ENotifyException do
        Check(False,
          'dsClose OnEntry should not have fired as GuardProc should have prevented transition');
      on E: EGuardFailure do
        Check(True, 'as expected');
    end;
  finally
    FDoorStates.Free;
  end;
end;

procedure TestTConfiguredState.TestEnumNoOnExitWithFailingGuard;
var
  LOnExit: TTransitionProc;
  LFailingGuard: TGuardProc<TDoorTriggers>;
  FDoorStates: TStateMachine<TDoorStates, TDoorTriggers>;
begin
  LOnExit := procedure
    begin
      raise ENotifyException.Create('In OnExit');
    end;

  LFailingGuard := function(Trigger : TDoorTriggers): boolean
    begin
      Result := False;
    end;

  FDoorStates := TStateMachine<TDoorStates, TDoorTriggers>.Create;
  try
    FDoorStates.State(TDoorStates.dsOpen).Initial.OnExit(LOnExit)
      .Trigger(dtClose, dsClosed, LFailingGuard);
    FDoorStates.State(dsClosed).Trigger(dtOpen, dsOpen);
    FDoorStates.Active := True;
    try
      FDoorStates.CurrentState.Execute(dtClose);
    except
      on E: ENotifyException do
        Check(False,
          'dsOpen OnExit should not have fired as GuardProc should have prevented transition');
      on E: EGuardFailure do
        Check(True, 'as expected');
    end;
  finally
    FDoorStates.Free;
  end;
end;

procedure TestTConfiguredState.TestEnumOnEntry;
var
  LOnEntry: TTransitionProc;
  FDoorStates: TStateMachine<TDoorStates, TDoorTriggers>;
begin
  LOnEntry := procedure
    begin
      raise ENotifyException.Create('In OnEntry');
    end;

  FDoorStates := TStateMachine<TDoorStates, TDoorTriggers>.Create;
  try
    FDoorStates.State(TDoorStates.dsOpen).Initial.Trigger(dtClose, dsClosed);
    FDoorStates.State(dsClosed).OnEntry(LOnEntry).Trigger(dtOpen, dsOpen);
    FDoorStates.Active := True;
    try
      FDoorStates.CurrentState.Execute(dtClose);
      Check(False, 'dsClosed OnEntry failed to fire');
    except
      on E: ENotifyException do
        Check(True, 'as expected');
    end;
  finally
    FDoorStates.Free;
  end;
end;

procedure TestTConfiguredState.TestEnumOnExit;
var
  LOnExit: TTransitionProc;
  FDoorStates: TStateMachine<TDoorStates, TDoorTriggers>;
begin
  LOnExit := procedure
    begin
      raise ENotifyException.Create('In OnExit');
    end;

  FDoorStates := TStateMachine<TDoorStates, TDoorTriggers>.Create;
  try
    FDoorStates.State(TDoorStates.dsOpen).Initial.OnExit(LOnExit)
      .Trigger(dtClose, dsClosed);
    FDoorStates.State(dsClosed).Trigger(dtOpen, dsOpen);
    FDoorStates.Active := True;
    try
      FDoorStates.CurrentState.Execute(dtClose);
      Check(False, 'dsOpen OnExit failed to fire');
    except
      on E: ENotifyException do
        Check(True, 'as expected');
    end;
  finally
    FDoorStates.Free;
  end;
end;

procedure TestTConfiguredState.TestStringInitialStateOnEntry;
var
  LOnEntry: TTransitionProc;
  FDoorStates: TStateMachine<string, string>;
begin
  LOnEntry := procedure
    begin
      raise ENotifyException.Create('In OnEntry');
    end;

  FDoorStates := TStateMachine<string, string>.Create;
  try
    FDoorStates.State(DoorStateOpen).Initial.OnEntry(LOnEntry)
      .Trigger(DoorTriggerClose, DoorStateClosed);
    FDoorStates.State(DoorStateClosed).Trigger(DoorTriggerOpen, DoorStateOpen);
    try
      FDoorStates.Active := True;
      Check(False,
        'Initial State DoorStateOpen OnEntry failed to fire on Activate');
    except
      on E: ENotifyException do
        Check(True, 'as expected');
    end;
  finally
    FDoorStates.Free;
  end;
end;

procedure TestTConfiguredState.TestStringNoOnEntryWithFailingGuard;
var
  LOnEntry: TTransitionProc;
  LFailingGuard: TGuardProc<string>;
  FDoorStates: TStateMachine<string, string>;
begin
  LOnEntry := procedure
    begin
      raise ENotifyException.Create('In OnExit');
    end;

  LFailingGuard := function(Trigger : string): boolean
    begin
      Result := False;
    end;

  FDoorStates := TStateMachine<string, string>.Create;
  try
    FDoorStates.State(DoorStateOpen).Initial.Trigger(DoorTriggerClose,
      DoorStateClosed, LFailingGuard);
    FDoorStates.State(DoorStateClosed).OnEntry(LOnEntry)
      .Trigger(DoorTriggerOpen, DoorStateOpen);
    FDoorStates.Active := True;
    try
      FDoorStates.CurrentState.Execute(DoorTriggerClose);
    except
      on E: ENotifyException do
        Check(False,
          'dsClose OnEntry should not have fired as GuardProc should have prevented transition');
      on E: EGuardFailure do
        Check(True, 'as expected');
    end;
  finally
    FDoorStates.Free;
  end;
end;

procedure TestTConfiguredState.TestStringNoOnExitWithFailingGuard;
var
  LOnExit: TTransitionProc;
  LFailingGuard: TGuardProc<string>;
  FDoorStates: TStateMachine<string, string>;
begin
  LOnExit := procedure
    begin
      raise ENotifyException.Create('In OnExit');
    end;

  LFailingGuard := function(Trigger : string): boolean
    begin
      Result := False;
    end;

  FDoorStates := TStateMachine<string, string>.Create;
  try
    FDoorStates.State(DoorStateOpen).Initial.OnExit(LOnExit)
      .Trigger(DoorTriggerClose, DoorStateClosed, LFailingGuard);
    FDoorStates.State(DoorStateClosed).Trigger(DoorTriggerOpen, DoorStateOpen);
    FDoorStates.Active := True;
    try
      FDoorStates.CurrentState.Execute(DoorTriggerClose);
    except
      on E: ENotifyException do
        Check(False,
          'dsOpen OnExit should not have fired as GuardProc should have prevented transition');
      on E: EGuardFailure do
        Check(True, 'as expected');
    end;
  finally
    FDoorStates.Free;
  end;
end;

procedure TestTConfiguredState.TestStringOnEntry;
var
  LOnEntry: TTransitionProc;
  FDoorStates: TStateMachine<string, string>;
begin
  LOnEntry := procedure
    begin
      raise ENotifyException.Create('In OnEntry');
    end;

  FDoorStates := TStateMachine<string, string>.Create;
  try
    FDoorStates.State(DoorStateOpen).Initial.Trigger(DoorTriggerClose,
      DoorStateClosed);
    FDoorStates.State(DoorStateClosed).OnEntry(LOnEntry)
      .Trigger(DoorTriggerOpen, DoorStateOpen);
    FDoorStates.Active := True;
    try
      FDoorStates.CurrentState.Execute(DoorTriggerClose);
      Check(False, 'dsClosed OnEntry failed to fire');
    except
      on E: ENotifyException do
        Check(True, 'as expected');
    end;
  finally
    FDoorStates.Free;
  end;
end;

procedure TestTConfiguredState.TestStringOnExit;
var
  LOnExit: TTransitionProc;
  FDoorStates: TStateMachine<string, string>;
begin
  LOnExit := procedure
    begin
      raise ENotifyException.Create('In OnExit');
    end;

  FDoorStates := TStateMachine<string, string>.Create;
  try
    FDoorStates.State(DoorStateOpen).Initial.OnExit(LOnExit)
      .Trigger(DoorTriggerClose, DoorStateClosed);
    FDoorStates.State(DoorStateClosed).Trigger(DoorTriggerOpen, DoorStateOpen);
    FDoorStates.Active := True;
    try
      FDoorStates.CurrentState.Execute(DoorTriggerClose);
      Check(False, 'dsOpen OnExit failed to fire');
    except
      on E: ENotifyException do
        Check(True, 'as expected');
    end;
  finally
    FDoorStates.Free;
  end;
end;

procedure TestTStateMachine.TestActiveWithNoInitialState;
var
  FDoorStates: TStateMachine<TDoorStates, TDoorTriggers>;
begin
  FDoorStates := TStateMachine<TDoorStates, TDoorTriggers>.Create;
  try
    FDoorStates.State(TDoorStates.dsOpen).Trigger(TDoorTriggers.dtClose,
      TDoorStates.dsClosed);
    FDoorStates.State(TDoorStates.dsClosed).Trigger(TDoorTriggers.dtOpen,
      TDoorStates.dsOpen);
    try
      FDoorStates.Active := True;
      Check(false, 'Activating Statemachine with no Initial state should have failed but did not');
    except
      on E: EInvalidStateMachine do
        Check(true, 'As expected for a statemachine with no initial state');
    end;
  finally
    FDoorStates.Free;
  end;
end;

procedure TestTStateMachine.TestAddState;
var
  FDoorStates: TStateMachine<TDoorStates, TDoorTriggers>;
begin
  FDoorStates := TStateMachine<TDoorStates, TDoorTriggers>.Create;
  try
    Check(FDoorStates.StateCount = 0,
      Format('New Statemachine should have zero states, but has %d',
      [FDoorStates.StateCount]));
    FDoorStates.State(TDoorStates.dsOpen);
    Check(FDoorStates.StateCount = 1,
      Format('Statemachine should have 1 state, but has %d',
      [FDoorStates.StateCount]));
  finally
    FDoorStates.Free;
  end;
end;

procedure TestTStateMachine.TestTwoInitialStates;
var
  FDoorStates: TStateMachine<TDoorStates, TDoorTriggers>;
begin
  FDoorStates := TStateMachine<TDoorStates, TDoorTriggers>.Create;
  try
    FDoorStates
      .State(TDoorStates.dsOpen)
        .Initial
        .Trigger(TDoorTriggers.dtClose, TDoorStates.dsClosed);
    try
      FDoorStates
        .State(TDoorStates.dsClosed)
          .Initial
          .Trigger(TDoorTriggers.dtOpen, TDoorStates.dsOpen);
      Check(false, 'Adding a second initial state should have failed but did not');
    except
      on E: EInvalidStateMachine do
        Check(true, 'As expected for a statemachine with two initial states');
    end;
  finally
    FDoorStates.Free;
  end;
end;

procedure TestTStateMachine.TestUnreachableStates;
var
  FDoorStates: TStateMachine<TDoorStates, TDoorTriggers>;
begin
  FDoorStates := TStateMachine<TDoorStates, TDoorTriggers>.Create;
  try
    FDoorStates
      .State(TDoorStates.dsOpen)
        .Initial
        .Trigger(TDoorTriggers.dtClose, TDoorStates.dsClosed);
    FDoorStates
      .State(TDoorStates.dsClosed)
        .Trigger(TDoorTriggers.dtOpen, TDoorStates.dsOpen);
    FDoorStates
      .State(TDoorStates.dsSlightlyAjar)  // unreachable state
        .Trigger(TDoorTriggers.dtOpen, TDoorStates.dsOpen)
        .Trigger(TDoorTriggers.dtClose, TDoorStates.dsClosed);
    FDoorStates
      .State(TDoorStates.dsMoreAjar)      // unreachable state
        .Trigger(TDoorTriggers.dtOpen, TDoorStates.dsOpen)
        .Trigger(TDoorTriggers.dtClose, TDoorStates.dsClosed);
    try
      FDoorStates.Validate;
      Check(false, 'Two unreachable states, so validate should have failed');
    except
      on E: EInvalidStateMachine do
        Check(true, 'As expected for a statemachine with two unreachable states');
    end;
  finally
    FDoorStates.Free;
  end;
end;

{ TestEnumDoorStates }

procedure TestEnumDoorStates.SetUp;
begin
  FDoorStates := TStateMachine<TDoorStates, TDoorTriggers>.Create;
  FDoorStates.State(TDoorStates.dsOpen)
                .Trigger(TDoorTriggers.dtClose, TDoorStates.dsClosed);
  FDoorStates.State(TDoorStates.dsClosed)
                .Initial
                .Trigger(TDoorTriggers.dtOpen, TDoorStates.dsOpen);
  FDoorStates.Active := True;
end;

procedure TestEnumDoorStates.TearDown;
begin
  FDoorStates.Active := False;
  FDoorStates.Free;
  inherited;
end;

procedure TestEnumDoorStates.TestInitialState;
begin
  Check(FDoorStates.CurrentState <> nil, 'CurrentState should not be nil');
  Check(FDoorStates.CurrentState.State = TDoorStates.dsClosed,
    'Initial state should be dsClosed');
end;

procedure TestEnumDoorStates.TestTriggerExistsFalse;
begin
  Check(FDoorStates.CurrentState.State = TDoorStates.dsClosed,
    'Initial state should be Closed');
  CheckTrue(FDoorStates.CurrentState.TriggerExists(dtOpen), 'TriggerExists(dtOpen) should return true from Closed state');
end;

procedure TestEnumDoorStates.TestTriggerExists;
begin
  Check(FDoorStates.CurrentState.State = TDoorStates.dsClosed,
    'Initial state should be Closed');
  CheckFalse(FDoorStates.CurrentState.TriggerExists(dtClose), 'TriggerExists(dtClose) should return false from Closed state');
end;

procedure TestEnumDoorStates.TestNumberOfStates;
begin
  CheckEquals(2, FDoorStates.StateCount,
    Format('Should be 2 states, actually is %d', [FDoorStates.StateCount]));
end;

procedure TestEnumDoorStates.TestTriggerNoGuard;
begin
  Check(FDoorStates.CurrentState.State = TDoorStates.dsClosed,
    'Initial state should be Closed');
  FDoorStates.CurrentState.Execute(TDoorTriggers.dtOpen);
  Check(FDoorStates.CurrentState.State = TDoorStates.dsOpen,
    'State should have transitioned to Open');
end;

{ TestStringDoorStates }

procedure TestStringDoorStates.SetUp;
begin
  inherited;
  FDoorStates := TStateMachine<String, String>.Create;
  FDoorStates.State(DoorStateOpen).Trigger(DoorTriggerClose, DoorStateClosed);
  FDoorStates.State(DoorStateClosed).Initial.Trigger(DoorTriggerOpen,
    DoorStateOpen);
  FDoorStates.Active := True;
end;

procedure TestStringDoorStates.TearDown;
begin
  FDoorStates.Active := False;
  FDoorStates.Free;
  inherited;
end;

procedure TestStringDoorStates.TestInitialState;
begin
  Check(FDoorStates.CurrentState <> nil, 'CurrentState should not be nil');
  Check(FDoorStates.CurrentState.State = DoorStateClosed,
    'Initial state should be Closed');
end;

procedure TestStringDoorStates.TestNumberOfStates;
begin
  CheckEquals(2, FDoorStates.StateCount,
    Format('Should be 2 states, actually is %d', [FDoorStates.StateCount]));
end;

procedure TestStringDoorStates.TestTriggerNoGuard;
begin
  Check(FDoorStates.CurrentState.State = DoorStateClosed,
    'Initial state should be Closed');
  FDoorStates.CurrentState.Execute(DoorTriggerOpen);
  Check(FDoorStates.CurrentState.State = DoorStateOpen,
    'State should have transitioned to Open');
end;

initialization

// Register any test cases with the test runner
RegisterTest('Unit Tests', TestTConfiguredTrigger.Suite);
RegisterTest('Unit Tests', TestTConfiguredState.Suite);
RegisterTest('Unit Tests', TestTStateMachine.Suite);
RegisterTest('Unit Tests', TestEnumDoorStates.Suite);
RegisterTest('Unit Tests', TestStringDoorStates.Suite);

end.
